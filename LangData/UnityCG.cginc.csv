#ifndef@#ifndef@Example: #ifndef UNITY_CG_INCLUDED
UNITY_CG_INCLUDED@UNITY_CG_INCLUDED@Example: #ifndef UNITY_CG_INCLUDED
UNITY_CG_INCLUDED@UNITY_CG_INCLUDED@Body: #define UNITY_CG_INCLUDED
#include@#include@Example: #include "UnityShaderVariables.cginc"
UnityShaderVariables@UnityShaderVariables@Example: #include "UnityShaderVariables.cginc"
cginc@cginc@Example: #include "UnityShaderVariables.cginc"
#endif@#endif@Body: #endif
defined@defined@Example: #if defined(SHADER_API_PS3)
SHADER_API_PS3@SHADER_API_PS3@Example: #if defined(SHADER_API_PS3)
define@define@Example: #	define UNITY_SAMPLE_DEPTH(value) (dot((value).wxy, float3(0.996093809371817670572857294849, 0.0038909914428586627756752238080039, 1.5199185323666651467481343000015e-5)))
UNITY_SAMPLE_DEPTH@UNITY_SAMPLE_DEPTH@Example: #	define UNITY_SAMPLE_DEPTH(value) (dot((value).wxy, float3(0.996093809371817670572857294849, 0.0038909914428586627756752238080039, 1.5199185323666651467481343000015e-5)))
value@value@Example: #	define UNITY_SAMPLE_DEPTH(value) (dot((value).wxy, float3(0.996093809371817670572857294849, 0.0038909914428586627756752238080039, 1.5199185323666651467481343000015e-5)))
value@value@Example: #	define UNITY_SAMPLE_DEPTH(value) (dot((value).wxy, float3(0.996093809371817670572857294849, 0.0038909914428586627756752238080039, 1.5199185323666651467481343000015e-5)))
float3@float3@Example: #	define UNITY_SAMPLE_DEPTH(value) (dot((value).wxy, float3(0.996093809371817670572857294849, 0.0038909914428586627756752238080039, 1.5199185323666651467481343000015e-5)))
996093809371817670572857294849@996093809371817670572857294849@Example: #	define UNITY_SAMPLE_DEPTH(value) (dot((value).wxy, float3(0.996093809371817670572857294849, 0.0038909914428586627756752238080039, 1.5199185323666651467481343000015e-5)))
0038909914428586627756752238080039@0038909914428586627756752238080039@Example: #	define UNITY_SAMPLE_DEPTH(value) (dot((value).wxy, float3(0.996093809371817670572857294849, 0.0038909914428586627756752238080039, 1.5199185323666651467481343000015e-5)))
5199185323666651467481343000015e@5199185323666651467481343000015e@Example: #	define UNITY_SAMPLE_DEPTH(value) (dot((value).wxy, float3(0.996093809371817670572857294849, 0.0038909914428586627756752238080039, 1.5199185323666651467481343000015e-5)))
helper@helper@Example: //  helper functions and macros used in many standard shaders
functions@functions@Example: //  helper functions and macros used in many standard shaders
macros@macros@Example: //  helper functions and macros used in many standard shaders
used@used@Example: //  helper functions and macros used in many standard shaders
many@many@Example: //  helper functions and macros used in many standard shaders
standard@standard@Example: //  helper functions and macros used in many standard shaders
shaders@shaders@Example: //  helper functions and macros used in many standard shaders
defined@defined@Example: #if defined (DIRECTIONAL) || defined (DIRECTIONAL_COOKIE) || defined (POINT) || defined (SPOT) || defined (POINT_NOATT) || defined (POINT_COOKIE)
DIRECTIONAL@DIRECTIONAL@Example: #if defined (DIRECTIONAL) || defined (DIRECTIONAL_COOKIE) || defined (POINT) || defined (SPOT) || defined (POINT_NOATT) || defined (POINT_COOKIE)
defined@defined@Example: #if defined (DIRECTIONAL) || defined (DIRECTIONAL_COOKIE) || defined (POINT) || defined (SPOT) || defined (POINT_NOATT) || defined (POINT_COOKIE)
DIRECTIONAL_COOKIE@DIRECTIONAL_COOKIE@Example: #if defined (DIRECTIONAL) || defined (DIRECTIONAL_COOKIE) || defined (POINT) || defined (SPOT) || defined (POINT_NOATT) || defined (POINT_COOKIE)
defined@defined@Example: #if defined (DIRECTIONAL) || defined (DIRECTIONAL_COOKIE) || defined (POINT) || defined (SPOT) || defined (POINT_NOATT) || defined (POINT_COOKIE)
POINT@POINT@Example: #if defined (DIRECTIONAL) || defined (DIRECTIONAL_COOKIE) || defined (POINT) || defined (SPOT) || defined (POINT_NOATT) || defined (POINT_COOKIE)
defined@defined@Example: #if defined (DIRECTIONAL) || defined (DIRECTIONAL_COOKIE) || defined (POINT) || defined (SPOT) || defined (POINT_NOATT) || defined (POINT_COOKIE)
SPOT@SPOT@Example: #if defined (DIRECTIONAL) || defined (DIRECTIONAL_COOKIE) || defined (POINT) || defined (SPOT) || defined (POINT_NOATT) || defined (POINT_COOKIE)
defined@defined@Example: #if defined (DIRECTIONAL) || defined (DIRECTIONAL_COOKIE) || defined (POINT) || defined (SPOT) || defined (POINT_NOATT) || defined (POINT_COOKIE)
POINT_NOATT@POINT_NOATT@Example: #if defined (DIRECTIONAL) || defined (DIRECTIONAL_COOKIE) || defined (POINT) || defined (SPOT) || defined (POINT_NOATT) || defined (POINT_COOKIE)
defined@defined@Example: #if defined (DIRECTIONAL) || defined (DIRECTIONAL_COOKIE) || defined (POINT) || defined (SPOT) || defined (POINT_NOATT) || defined (POINT_COOKIE)
POINT_COOKIE@POINT_COOKIE@Example: #if defined (DIRECTIONAL) || defined (DIRECTIONAL_COOKIE) || defined (POINT) || defined (SPOT) || defined (POINT_NOATT) || defined (POINT_COOKIE)
USING_LIGHT_MULTI_COMPILE@USING_LIGHT_MULTI_COMPILE@Body: #define USING_LIGHT_MULTI_COMPILE
#endif@#endif@Body: #endif
SCALED_NORMAL@SCALED_NORMAL@Body: #define SCALED_NORMAL (v.normal * unity_Scale.w)
float4@float4@Example: float4 vertex : POSITION;
vertex@vertex@Example: float4 vertex : POSITION;
POSITION@POSITION@Example: float4 vertex : POSITION;
Fog@Fog@Example: Fog { Mode Off }
Mode@Mode@Example: Fog { Mode Off }
float3@float3@Example: float3 normal : NORMAL;
normal@normal@Example: float3 normal : NORMAL;
NORMAL@NORMAL@Example: float3 normal : NORMAL;
float4@float4@Example: float4 texcoord : TEXCOORD0;
texcoord@texcoord@Example: float4 texcoord : TEXCOORD0;
TEXCOORD0@TEXCOORD0@Example: float4 texcoord : TEXCOORD0;
float4@float4@Example: float4 vertex : POSITION;
vertex@vertex@Example: float4 vertex : POSITION;
POSITION@POSITION@Example: float4 vertex : POSITION;
float4@float4@Example: float4 tangent : TANGENT;
tangent@tangent@Example: float4 tangent : TANGENT;
TANGENT@TANGENT@Example: float4 tangent : TANGENT;
float3@float3@Example: float3 normal : NORMAL;
normal@normal@Example: float3 normal : NORMAL;
NORMAL@NORMAL@Example: float3 normal : NORMAL;
float4@float4@Example: float4 texcoord : TEXCOORD0;
texcoord@texcoord@Example: float4 texcoord : TEXCOORD0;
TEXCOORD0@TEXCOORD0@Example: float4 texcoord : TEXCOORD0;
float4@float4@Example: float4 vertex : POSITION;
vertex@vertex@Example: float4 vertex : POSITION;
POSITION@POSITION@Example: float4 vertex : POSITION;
float4@float4@Example: float4 tangent : TANGENT;
tangent@tangent@Example: float4 tangent : TANGENT;
TANGENT@TANGENT@Example: float4 tangent : TANGENT;
float3@float3@Example: float3 normal : NORMAL;
normal@normal@Example: float3 normal : NORMAL;
NORMAL@NORMAL@Example: float3 normal : NORMAL;
float4@float4@Example: float4 texcoord : TEXCOORD0;
texcoord@texcoord@Example: float4 texcoord : TEXCOORD0;
TEXCOORD0@TEXCOORD0@Example: float4 texcoord : TEXCOORD0;
float4@float4@Example: float4 texcoord1 : TEXCOORD1;
texcoord1@texcoord1@Example: float4 texcoord1 : TEXCOORD1;
TEXCOORD1@TEXCOORD1@Example: float4 texcoord1 : TEXCOORD1;
fixed4@fixed4@Example: fixed4 color : COLOR;
color@color@Example: fixed4 color : COLOR;
COLOR@COLOR@Example: fixed4 color : COLOR;
defined@defined@Example: #if defined(SHADER_API_XBOX360)
SHADER_API_XBOX360@SHADER_API_XBOX360@Example: #if defined(SHADER_API_XBOX360)
half4@half4@Example: half4 texcoord2 : TEXCOORD2;
texcoord2@texcoord2@Example: half4 texcoord2 : TEXCOORD2;
TEXCOORD2@TEXCOORD2@Example: half4 texcoord2 : TEXCOORD2;
half4@half4@Example: half4 texcoord3 : TEXCOORD3;
texcoord3@texcoord3@Example: half4 texcoord3 : TEXCOORD3;
TEXCOORD3@TEXCOORD3@Example: half4 texcoord3 : TEXCOORD3;
half4@half4@Example: half4 texcoord4 : TEXCOORD4;
texcoord4@texcoord4@Example: half4 texcoord4 : TEXCOORD4;
TEXCOORD4@TEXCOORD4@Example: half4 texcoord4 : TEXCOORD4;
half4@half4@Example: half4 texcoord5 : TEXCOORD5;
texcoord5@texcoord5@Example: half4 texcoord5 : TEXCOORD5;
TEXCOORD5@TEXCOORD5@Example: half4 texcoord5 : TEXCOORD5;
#endif@#endif@Body: #endif
Computes@Computes@Example: // Computes world space light direction
world@world@Example: // Computes world space light direction
space@space@Example: // Computes world space light direction
light@light@Example: // Computes world space light direction
direction@direction@Example: // Computes world space light direction
WorldSpaceLightDir(infloat4v)@WorldSpaceLightDir( in float4 v )@@Body: float3 WorldSpaceLightDir( in float4 v )
{
float3 worldPos = mul(_Object2World, v).xyz;
#ifndef USING_LIGHT_MULTI_COMPILE
return _WorldSpaceLightPos0.xyz - worldPos * _WorldSpaceLightPos0.w;
#else
		#ifndef USING_DIRECTIONAL_LIGHT
		return _WorldSpaceLightPos0.xyz - worldPos;
#else
		return _WorldSpaceLightPos0.xyz;
#endif
#endif
}
@
Computes@Computes@Example: // Computes object space light direction
object@object@Example: // Computes object space light direction
space@space@Example: // Computes object space light direction
light@light@Example: // Computes object space light direction
direction@direction@Example: // Computes object space light direction
ObjSpaceLightDir(infloat4v)@ObjSpaceLightDir( in float4 v )@@Body: float3 ObjSpaceLightDir( in float4 v )
{
float3 objSpaceLightPos = mul(_World2Object, _WorldSpaceLightPos0).xyz;
#ifndef USING_LIGHT_MULTI_COMPILE
return objSpaceLightPos.xyz - v.xyz * _WorldSpaceLightPos0.w;
#else
		#ifndef USING_DIRECTIONAL_LIGHT
		return objSpaceLightPos.xyz * unity_Scale.w - v.xyz;
#else
		return objSpaceLightPos.xyz;
#endif
#endif
}
@
Computes@Computes@Example: // Computes world space view direction
world@world@Example: // Computes world space view direction
space@space@Example: // Computes world space view direction
view@view@Example: // Computes world space view direction
direction@direction@Example: // Computes world space view direction
WorldSpaceViewDir(infloat4v)@WorldSpaceViewDir( in float4 v )@@Body: float3 WorldSpaceViewDir( in float4 v )
{
return _WorldSpaceCameraPos.xyz - mul(_Object2World, v).xyz;
}
@
Computes@Computes@Example: // Computes object space view direction
object@object@Example: // Computes object space view direction
space@space@Example: // Computes object space view direction
view@view@Example: // Computes object space view direction
direction@direction@Example: // Computes object space view direction
ObjSpaceViewDir(infloat4v)@ObjSpaceViewDir( in float4 v )@@Body: float3 ObjSpaceViewDir( in float4 v )
{
float3 objSpaceCameraPos = mul(_World2Object, float4(_WorldSpaceCameraPos.xyz, 1)).xyz * unity_Scale.w;
return objSpaceCameraPos - v.xyz;
}
@
Declares@Declares@Example: // Declares 3x3 matrix 'rotation', filled with tangent space basis
matrix@matrix@Example: // Declares 3x3 matrix 'rotation', filled with tangent space basis
'rotation'@'rotation'@Example: // Declares 3x3 matrix 'rotation', filled with tangent space basis
filled@filled@Example: // Declares 3x3 matrix 'rotation', filled with tangent space basis
with@with@Example: // Declares 3x3 matrix 'rotation', filled with tangent space basis
tangent@tangent@Example: // Declares 3x3 matrix 'rotation', filled with tangent space basis
space@space@Example: // Declares 3x3 matrix 'rotation', filled with tangent space basis
basis@basis@Example: // Declares 3x3 matrix 'rotation', filled with tangent space basis
TANGENT_SPACE_ROTATION@TANGENT_SPACE_ROTATION@Body: #define TANGENT_SPACE_ROTATION \
float3@float3@Example: float3 binormal = cross( v.normal, v.tangent.xyz ) * v.tangent.w;
binormal@binormal@Example: float3 binormal = cross( v.normal, v.tangent.xyz ) * v.tangent.w;
cross@cross@Example: float3 binormal = cross( v.normal, v.tangent.xyz ) * v.tangent.w;
normal@normal@Example: float3 binormal = cross( v.normal, v.tangent.xyz ) * v.tangent.w;
tangent@tangent@Example: float3 binormal = cross( v.normal, v.tangent.xyz ) * v.tangent.w;
tangent@tangent@Example: float3 binormal = cross( v.normal, v.tangent.xyz ) * v.tangent.w;
float3x3rotation=float3x3(v.tangent.xyz,binormal,v.normal)float3Shade4PointLights(float4lightPosX,float4lightPosY,float4lightPosZ,float3lightColor0,float3lightColor1,float3lightColor2,float3lightColor3,float4lightAttenSq,float3pos,float3normal)@float3x3 rotation = float3x3( v.tangent.xyz, binormal, v.normal )float3 Shade4PointLights (	float4 lightPosX, float4 lightPosY, float4 lightPosZ,	float3 lightColor0, float3 lightColor1, float3 lightColor2, float3 lightColor3,	float4 lightAttenSq,	float3 pos, float3 normal)@@Body: \ float3x3 rotation = float3x3( v.tangent.xyz, binormal, v.normal )


float3 Shade4PointLights (
	float4 lightPosX, float4 lightPosY, float4 lightPosZ,
	float3 lightColor0, float3 lightColor1, float3 lightColor2, float3 lightColor3,
	float4 lightAttenSq,
	float3 pos, float3 normal)
{
// to light vectors
float4 toLightX = lightPosX - pos.x;
float4 toLightY = lightPosY - pos.y;
float4 toLightZ = lightPosZ - pos.z;
// squared lengths
float4 lengthSq = 0;
lengthSq += toLightX * toLightX;
lengthSq += toLightY * toLightY;
lengthSq += toLightZ * toLightZ;
// NdotL
float4 ndotl = 0;
ndotl += toLightX * normal.x;
ndotl += toLightY * normal.y;
ndotl += toLightZ * normal.z;
// correct NdotL
float4 corr = rsqrt(lengthSq);
ndotl = max (float4(0,0,0,0), ndotl * corr);
// attenuation
float4 atten = 1.0 / (1.0 + lengthSq * lightAttenSq);
float4 diff = ndotl * atten;
// final color
float3 col = 0;
col += lightColor0 * diff.x;
col += lightColor1 * diff.y;
col += lightColor2 * diff.z;
col += lightColor3 * diff.w;
return col;
}
@
ShadeVertexLights(float4vertex,float3normal)@ShadeVertexLights (float4 vertex, float3 normal)@@Body: float3 ShadeVertexLights (float4 vertex, float3 normal)
{
float3 viewpos = mul (UNITY_MATRIX_MV, vertex).xyz;
float3 viewN = mul ((float3x3)UNITY_MATRIX_IT_MV, normal);
float3 lightColor = UNITY_LIGHTMODEL_AMBIENT.xyz;
for (int i = 0;
i < 4;
i++
{
float3 toLight = unity_LightPosition[i].xyz - viewpos.xyz * unity_LightPosition[i].w;
float lengthSq = dot(toLight, toLight);
float atten = 1.0 / (1.0 + lengthSq * unity_LightAtten[i].z);
float diff = max (0, dot (viewN, normalize(toLight)));
lightColor += unity_LightColor[i].rgb * (diff * atten);

}
return lightColor;
}
@
normal@normal@Example: // normal should be normalized, w=1.0
should@should@Example: // normal should be normalized, w=1.0
normalized@normalized@Example: // normal should be normalized, w=1.0
ShadeSH9(half4normal)@ShadeSH9 (half4 normal)@@Body: half3 ShadeSH9 (half4 normal)
{
half3 x1, x2, x3;
// Linear + constant polynomial terms
x1.r = dot(unity_SHAr,normal);
x1.g = dot(unity_SHAg,normal);
x1.b = dot(unity_SHAb,normal);
// 4 of the quadratic polynomials
half4 vB = normal.xyzz * normal.yzzx;
x2.r = dot(unity_SHBr,vB);
x2.g = dot(unity_SHBg,vB);
x2.b = dot(unity_SHBb,vB);
// Final quadratic polynomial
float vC = normal.x*normal.x - normal.y*normal.y;
x3 = unity_SHC.rgb * vC;
return x1 + x2 + x3;
}
@
Transforms@Transforms@Example: // Transforms 2D UV by scale/bias property
scale@scale@Example: // Transforms 2D UV by scale/bias property
bias@bias@Example: // Transforms 2D UV by scale/bias property
property@property@Example: // Transforms 2D UV by scale/bias property
TRANSFORM_TEX(tex,name)@TRANSFORM_TEX(tex,name)@Body: #define TRANSFORM_TEX(tex,name) (tex.xy * name##_ST.xy + name##_ST.zw)
Transforms@Transforms@Example: // Transforms 4D UV by a texture matrix (use only if you know exactly which matrix you need)
texture@texture@Example: // Transforms 4D UV by a texture matrix (use only if you know exactly which matrix you need)
matrix@matrix@Example: // Transforms 4D UV by a texture matrix (use only if you know exactly which matrix you need)
only@only@Example: // Transforms 4D UV by a texture matrix (use only if you know exactly which matrix you need)
know@know@Example: // Transforms 4D UV by a texture matrix (use only if you know exactly which matrix you need)
exactly@exactly@Example: // Transforms 4D UV by a texture matrix (use only if you know exactly which matrix you need)
which@which@Example: // Transforms 4D UV by a texture matrix (use only if you know exactly which matrix you need)
matrix@matrix@Example: // Transforms 4D UV by a texture matrix (use only if you know exactly which matrix you need)
need@need@Example: // Transforms 4D UV by a texture matrix (use only if you know exactly which matrix you need)
TRANSFORM_UV(idx)@TRANSFORM_UV(idx)@Body: #define TRANSFORM_UV(idx) mul (UNITY_MATRIX_TEXTURE##idx, v.texcoord).xy
float2@float2@Example: float2 uv	: TEXCOORD0;
TEXCOORD0@TEXCOORD0@Example: float2 uv	: TEXCOORD0;
fixed4@fixed4@Example: fixed4 diff	: COLOR0;
diff@diff@Example: fixed4 diff	: COLOR0;
COLOR0@COLOR0@Example: fixed4 diff	: COLOR0;
fixed4@fixed4@Example: fixed4 spec	: COLOR1;
spec@spec@Example: fixed4 spec	: COLOR1;
COLOR1@COLOR1@Example: fixed4 spec	: COLOR1;
VertexLight(v2f_vertex_liti,sampler2DmainTex)@VertexLight( v2f_vertex_lit i, sampler2D mainTex )@@Body: fixed4 VertexLight( v2f_vertex_lit i, sampler2D mainTex )
{
fixed4 texcol = tex2D( mainTex, i.uv );
fixed4 c;
c.xyz = ( texcol.xyz * i.diff.xyz + i.spec.xyz * texcol.a ) * 2;
c.w = texcol.w * i.diff.w;
return c;
}
@
Calculates@Calculates@Example: // Calculates UV offset for parallax bump mapping
offset@offset@Example: // Calculates UV offset for parallax bump mapping
parallax@parallax@Example: // Calculates UV offset for parallax bump mapping
bump@bump@Example: // Calculates UV offset for parallax bump mapping
mapping@mapping@Example: // Calculates UV offset for parallax bump mapping
ParallaxOffset(halfh,halfheight,half3viewDir)@ParallaxOffset( half h, half height, half3 viewDir )@@Body: float2 ParallaxOffset( half h, half height, half3 viewDir )
{
h = h * height - height/2.0;
float3 v = normalize(viewDir);
v.z += 0.42;
return h * (v.xy / v.z);
}
@
Converts@Converts@Example: // Converts color to luminance (grayscale)
color@color@Example: // Converts color to luminance (grayscale)
luminance@luminance@Example: // Converts color to luminance (grayscale)
grayscale@grayscale@Example: // Converts color to luminance (grayscale)
Luminance(fixed3c)@Luminance( fixed3 c )@@Body: fixed Luminance( fixed3 c )
{
return dot( c, fixed3(0.22, 0.707, 0.071) );
}
@
Decodes@Decodes@Example: // Decodes lightmaps:
lightmaps@lightmaps@Example: // Decodes lightmaps:
doubleLDR@doubleLDR@Example: // - doubleLDR encoded on GLES
encoded@encoded@Example: // - doubleLDR encoded on GLES
GLES@GLES@Example: // - doubleLDR encoded on GLES
RGBM@RGBM@Example: // - RGBM encoded with range [0;8] on other platforms using surface shaders
encoded@encoded@Example: // - RGBM encoded with range [0;8] on other platforms using surface shaders
with@with@Example: // - RGBM encoded with range [0;8] on other platforms using surface shaders
range@range@Example: // - RGBM encoded with range [0;8] on other platforms using surface shaders
other@other@Example: // - RGBM encoded with range [0;8] on other platforms using surface shaders
platforms@platforms@Example: // - RGBM encoded with range [0;8] on other platforms using surface shaders
using@using@Example: // - RGBM encoded with range [0;8] on other platforms using surface shaders
surface@surface@Example: // - RGBM encoded with range [0;8] on other platforms using surface shaders
shaders@shaders@Example: // - RGBM encoded with range [0;8] on other platforms using surface shaders
DecodeLightmap(fixed4color)@DecodeLightmap( fixed4 color )@@Body: fixed3 DecodeLightmap( fixed4 color )
{
#if (defined(SHADER_API_GLES) || defined(SHADER_API_GLES3)) && defined(SHADER_API_MOBILE)
return 2.0 * color.rgb;
#else
	// potentially faster to do the scalar multiplication
	// in parenthesis for scalar GPUs
	return (8.0 * color.a) * color.rgb;
#endif
}
@
Helpers@Helpers@Example: // Helpers used in image effects. Most image effects use the same
used@used@Example: // Helpers used in image effects. Most image effects use the same
image@image@Example: // Helpers used in image effects. Most image effects use the same
effects@effects@Example: // Helpers used in image effects. Most image effects use the same
Most@Most@Example: // Helpers used in image effects. Most image effects use the same
image@image@Example: // Helpers used in image effects. Most image effects use the same
effects@effects@Example: // Helpers used in image effects. Most image effects use the same
same@same@Example: // Helpers used in image effects. Most image effects use the same
minimal@minimal@Example: // minimal vertex shader (vert_img).
vertex@vertex@Example: // minimal vertex shader (vert_img).
shader@shader@Example: // minimal vertex shader (vert_img).
vert_img@vert_img@Example: // minimal vertex shader (vert_img).
float4@float4@Example: float4 vertex : POSITION;
vertex@vertex@Example: float4 vertex : POSITION;
POSITION@POSITION@Example: float4 vertex : POSITION;
half2@half2@Example: half2 texcoord : TEXCOORD0;
texcoord@texcoord@Example: half2 texcoord : TEXCOORD0;
TEXCOORD0@TEXCOORD0@Example: half2 texcoord : TEXCOORD0;
float4@float4@Example: float4 pos : SV_POSITION;
SV_POSITION@SV_POSITION@Example: float4 pos : SV_POSITION;
half2@half2@Example: half2 uv : TEXCOORD0;
TEXCOORD0@TEXCOORD0@Example: half2 uv : TEXCOORD0;
MultiplyUV(float4x4mat,float2inUV)@MultiplyUV (float4x4 mat, float2 inUV) @@Body: float2 MultiplyUV (float4x4 mat, float2 inUV) 
{
float4 temp = float4 (inUV.x, inUV.y, 0, 0);
temp = mul (mat, temp);
return temp.xy;
}
@
vert_img(appdata_imgv)@vert_img( appdata_img v )@@Body: v2f_img vert_img( appdata_img v )
{
v2f_img o;
o.pos = mul (UNITY_MATRIX_MVP, v.vertex);
o.uv = MultiplyUV( UNITY_MATRIX_TEXTURE0, v.texcoord );
return o;
}
@
Encoding@Encoding@Example: // Encoding/decoding [0..1) floats into 8 bit/channel RGBA. Note that 1.0 will not be encoded properly.
decoding@decoding@Example: // Encoding/decoding [0..1) floats into 8 bit/channel RGBA. Note that 1.0 will not be encoded properly.
floats@floats@Example: // Encoding/decoding [0..1) floats into 8 bit/channel RGBA. Note that 1.0 will not be encoded properly.
into@into@Example: // Encoding/decoding [0..1) floats into 8 bit/channel RGBA. Note that 1.0 will not be encoded properly.
channel@channel@Example: // Encoding/decoding [0..1) floats into 8 bit/channel RGBA. Note that 1.0 will not be encoded properly.
RGBA@RGBA@Example: // Encoding/decoding [0..1) floats into 8 bit/channel RGBA. Note that 1.0 will not be encoded properly.
Note@Note@Example: // Encoding/decoding [0..1) floats into 8 bit/channel RGBA. Note that 1.0 will not be encoded properly.
that@that@Example: // Encoding/decoding [0..1) floats into 8 bit/channel RGBA. Note that 1.0 will not be encoded properly.
will@will@Example: // Encoding/decoding [0..1) floats into 8 bit/channel RGBA. Note that 1.0 will not be encoded properly.
encoded@encoded@Example: // Encoding/decoding [0..1) floats into 8 bit/channel RGBA. Note that 1.0 will not be encoded properly.
properly@properly@Example: // Encoding/decoding [0..1) floats into 8 bit/channel RGBA. Note that 1.0 will not be encoded properly.
EncodeFloatRGBA(floatv)@EncodeFloatRGBA( float v )@@Body: float4 EncodeFloatRGBA( float v )
{
float4 kEncodeMul = float4(1.0, 255.0, 65025.0, 160581375.0);
float kEncodeBit = 1.0/255.0;
float4 enc = kEncodeMul * v;
enc = frac (enc);
enc -= enc.yzww * kEncodeBit;
return enc;
}
@
DecodeFloatRGBA(float4enc)@DecodeFloatRGBA( float4 enc )@@Body: float DecodeFloatRGBA( float4 enc )
{
float4 kDecodeDot = float4(1.0, 1/255.0, 1/65025.0, 1/160581375.0);
return dot( enc, kDecodeDot );
}
@
Encoding@Encoding@Example: // Encoding/decoding [0..1) floats into 8 bit/channel RG. Note that 1.0 will not be encoded properly.
decoding@decoding@Example: // Encoding/decoding [0..1) floats into 8 bit/channel RG. Note that 1.0 will not be encoded properly.
floats@floats@Example: // Encoding/decoding [0..1) floats into 8 bit/channel RG. Note that 1.0 will not be encoded properly.
into@into@Example: // Encoding/decoding [0..1) floats into 8 bit/channel RG. Note that 1.0 will not be encoded properly.
channel@channel@Example: // Encoding/decoding [0..1) floats into 8 bit/channel RG. Note that 1.0 will not be encoded properly.
Note@Note@Example: // Encoding/decoding [0..1) floats into 8 bit/channel RG. Note that 1.0 will not be encoded properly.
that@that@Example: // Encoding/decoding [0..1) floats into 8 bit/channel RG. Note that 1.0 will not be encoded properly.
will@will@Example: // Encoding/decoding [0..1) floats into 8 bit/channel RG. Note that 1.0 will not be encoded properly.
encoded@encoded@Example: // Encoding/decoding [0..1) floats into 8 bit/channel RG. Note that 1.0 will not be encoded properly.
properly@properly@Example: // Encoding/decoding [0..1) floats into 8 bit/channel RG. Note that 1.0 will not be encoded properly.
EncodeFloatRG(floatv)@EncodeFloatRG( float v )@@Body: float2 EncodeFloatRG( float v )
{
float2 kEncodeMul = float2(1.0, 255.0);
float kEncodeBit = 1.0/255.0;
float2 enc = kEncodeMul * v;
enc = frac (enc);
enc.x -= enc.y * kEncodeBit;
return enc;
}
@
DecodeFloatRG(float2enc)@DecodeFloatRG( float2 enc )@@Body: float DecodeFloatRG( float2 enc )
{
float2 kDecodeDot = float2(1.0, 1/255.0);
return dot( enc, kDecodeDot );
}
@
Encoding@Encoding@Example: // Encoding/decoding view space normals into 2D 0..1 vector
decoding@decoding@Example: // Encoding/decoding view space normals into 2D 0..1 vector
view@view@Example: // Encoding/decoding view space normals into 2D 0..1 vector
space@space@Example: // Encoding/decoding view space normals into 2D 0..1 vector
normals@normals@Example: // Encoding/decoding view space normals into 2D 0..1 vector
into@into@Example: // Encoding/decoding view space normals into 2D 0..1 vector
vector@vector@Example: // Encoding/decoding view space normals into 2D 0..1 vector
EncodeViewNormalStereo(float3n)@EncodeViewNormalStereo( float3 n )@@Body: float2 EncodeViewNormalStereo( float3 n )
{
float kScale = 1.7777;
float2 enc;
enc = n.xy / (n.z+1);
enc /= kScale;
enc = enc*0.5+0.5;
return enc;
}
@
DecodeViewNormalStereo(float4enc4)@DecodeViewNormalStereo( float4 enc4 )@@Body: float3 DecodeViewNormalStereo( float4 enc4 )
{
float kScale = 1.7777;
float3 nn = enc4.xyz*float3(2*kScale,2*kScale,0) + float3(-kScale,-kScale,1);
float g = 2.0 / dot(nn.xyz,nn.xyz);
float3 n;
n.xy = g*nn.xy;
n.z = g-1;
return n;
}
@
EncodeDepthNormal(floatdepth,float3normal)@EncodeDepthNormal( float depth, float3 normal )@@Body: float4 EncodeDepthNormal( float depth, float3 normal )
{
float4 enc;
enc.xy = EncodeViewNormalStereo (normal);
enc.zw = EncodeFloatRG (depth);
return enc;
}
@
DecodeDepthNormal(float4enc,outfloatdepth,outfloat3normal)@DecodeDepthNormal( float4 enc, out float depth, out float3 normal )@@Body: void DecodeDepthNormal( float4 enc, out float depth, out float3 normal )
{
depth = DecodeFloatRG (enc.zw);
normal = DecodeViewNormalStereo (enc);
}
@
UnpackNormalDXT5nm(fixed4packednormal)@UnpackNormalDXT5nm (fixed4 packednormal)@@Body: fixed3 UnpackNormalDXT5nm (fixed4 packednormal)
{
fixed3 normal;
normal.xy = packednormal.wy * 2 - 1;
#if defined(SHADER_API_FLASH)
// Flash does not have efficient saturate(), and dot() seems to require an extra register.
normal.z = sqrt(1 - normal.x*normal.x - normal.y*normal.y);
#else
	normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));
#endif
return normal;
}
@
UnpackNormal(fixed4packednormal)@UnpackNormal(fixed4 packednormal)@@Body: fixed3 UnpackNormal(fixed4 packednormal)
{
#if (defined(SHADER_API_GLES) || defined(SHADER_API_GLES3)) && defined(SHADER_API_MOBILE)
return packednormal.xyz * 2 - 1;
#else
	return UnpackNormalDXT5nm(packednormal);
#endif
}
@
buffer@buffer@Example: // Z buffer to linear 0..1 depth (0 at eye, 1 at far plane)
linear@linear@Example: // Z buffer to linear 0..1 depth (0 at eye, 1 at far plane)
depth@depth@Example: // Z buffer to linear 0..1 depth (0 at eye, 1 at far plane)
plane@plane@Example: // Z buffer to linear 0..1 depth (0 at eye, 1 at far plane)
Linear01Depth(floatz)@Linear01Depth( float z )@@Body: float Linear01Depth( float z )
{
return 1.0 / (_ZBufferParams.x * z + _ZBufferParams.y);
}
@
buffer@buffer@Example: // Z buffer to linear depth
linear@linear@Example: // Z buffer to linear depth
depth@depth@Example: // Z buffer to linear depth
LinearEyeDepth(floatz)@LinearEyeDepth( float z )@@Body: float LinearEyeDepth( float z )
{
return 1.0 / (_ZBufferParams.z * z + _ZBufferParams.w);
}
@
Depth@Depth@Example: // Depth render texture helpers
render@render@Example: // Depth render texture helpers
texture@texture@Example: // Depth render texture helpers
helpers@helpers@Example: // Depth render texture helpers
defined@defined@Example: #if defined(UNITY_MIGHT_NOT_HAVE_DEPTH_TEXTURE)
UNITY_MIGHT_NOT_HAVE_DEPTH_TEXTURE@UNITY_MIGHT_NOT_HAVE_DEPTH_TEXTURE@Example: #if defined(UNITY_MIGHT_NOT_HAVE_DEPTH_TEXTURE)
UNITY_TRANSFER_DEPTH(oo)@UNITY_TRANSFER_DEPTH(oo)@Body: #define UNITY_TRANSFER_DEPTH(oo) oo = o.pos.zw
SHADER_API_FLASH@SHADER_API_FLASH@Example: #if SHADER_API_FLASH
UNITY_OUTPUT_DEPTH(i)@UNITY_OUTPUT_DEPTH(i)@Body: #define UNITY_OUTPUT_DEPTH(i) return EncodeFloatRGBA(i.x/i.y)
#defineUNITY_OUTPUT_DEPTH(i)returni.x/i.y#endif#else#defineUNITY_TRANSFER_DEPTH(oo)#defineUNITY_OUTPUT_DEPTH(i)return0#endif#defineDECODE_EYEDEPTH(i)LinearEyeDepth(i)#defineCOMPUTE_EYEDEPTH(o)o=-mul(UNITY_MATRIX_MV,v.vertex).z#defineCOMPUTE_DEPTH_01-(mul(UNITY_MATRIX_MV,v.vertex).z*_ProjectionParams.w)#defineCOMPUTE_VIEW_NORMALmul((float3x3)UNITY_MATRIX_IT_MV,v.normal)//Projectedscreenpositionhelpers#defineV2F_SCREEN_TYPEfloat4inlinefloat4ComputeScreenPos(float4pos)@#define UNITY_OUTPUT_DEPTH(i) return i.x/i.y	#endif#else	#define UNITY_TRANSFER_DEPTH(oo) 	#define UNITY_OUTPUT_DEPTH(i) return 0#endif#define DECODE_EYEDEPTH(i) LinearEyeDepth(i)#define COMPUTE_EYEDEPTH(o) o = -mul( UNITY_MATRIX_MV, v.vertex ).z#define COMPUTE_DEPTH_01 -(mul( UNITY_MATRIX_MV, v.vertex ).z * _ProjectionParams.w)#define COMPUTE_VIEW_NORMAL mul((float3x3)UNITY_MATRIX_IT_MV, v.normal)// Projected screen position helpers#define V2F_SCREEN_TYPE float4inline float4 ComputeScreenPos (float4 pos) @@Body: #else #define UNITY_OUTPUT_DEPTH(i) return i.x/i.y
	#endif
#else
	#define UNITY_TRANSFER_DEPTH(oo) 
	#define UNITY_OUTPUT_DEPTH(i) return 0
#endif
#define DECODE_EYEDEPTH(i) LinearEyeDepth(i)
#define COMPUTE_EYEDEPTH(o) o = -mul( UNITY_MATRIX_MV, v.vertex ).z
#define COMPUTE_DEPTH_01 -(mul( UNITY_MATRIX_MV, v.vertex ).z * _ProjectionParams.w)
#define COMPUTE_VIEW_NORMAL mul((float3x3)UNITY_MATRIX_IT_MV, v.normal)

// Projected screen position helpers
#define V2F_SCREEN_TYPE float4
inline float4 ComputeScreenPos (float4 pos) 
{
float4 o = pos * 0.5f;
#if defined(UNITY_HALF_TEXEL_OFFSET)
o.xy = float2(o.x, o.y*_ProjectionParams.x) + o.w * _ScreenParams.zw;
#else
	o.xy = float2(o.x, o.y*_ProjectionParams.x) + o.w;
#endif
#if defined(SHADER_API_FLASH)
o.xy *= unity_NPOTScale.xy;
#endif
o.zw = pos.zw;
return o;
}
@
ComputeGrabScreenPos(float4pos)@ComputeGrabScreenPos (float4 pos) @@Body: float4 ComputeGrabScreenPos (float4 pos) 
{
#if UNITY_UV_STARTS_AT_TOP
float scale = -1.0;
#else
	float scale = 1.0;
#endif
float4 o = pos * 0.5f;
o.xy = float2(o.x, o.y*scale) + o.w;
o.zw = pos.zw;
return o;
}
@
snaps@snaps@Example: // snaps post-transformed position to screen pixels
post@post@Example: // snaps post-transformed position to screen pixels
transformed@transformed@Example: // snaps post-transformed position to screen pixels
position@position@Example: // snaps post-transformed position to screen pixels
screen@screen@Example: // snaps post-transformed position to screen pixels
pixels@pixels@Example: // snaps post-transformed position to screen pixels
UnityPixelSnap(float4pos)@UnityPixelSnap (float4 pos)@@Body: float4 UnityPixelSnap (float4 pos)
{
float2 hpc = _ScreenParams.xy * 0.5;
#ifdef UNITY_HALF_TEXEL_OFFSET
float2 hpcO = float2(-0.5,0.5);
#else
	float2 hpcO = float2(0,0);
#endif	
float2 pixelPos = floor ((pos.xy / pos.w) * hpc + 0.5);
pos.xy = (pixelPos + hpcO) / hpc * pos.w;
return pos;
}
@
TransformViewToProjection(float2v)@TransformViewToProjection (float2 v) @@Body: float2 TransformViewToProjection (float2 v) 
{
return float2(v.x*UNITY_MATRIX_P[0][0], v.y*UNITY_MATRIX_P[1][1]);
}
@
TransformViewToProjection(float3v)@TransformViewToProjection (float3 v) @@Body: float3 TransformViewToProjection (float3 v) 
{
return float3(v.x*UNITY_MATRIX_P[0][0], v.y*UNITY_MATRIX_P[1][1], v.z*UNITY_MATRIX_P[2][2]);
}
@
Shadow@Shadow@Example: // Shadow caster pass helpers
caster@caster@Example: // Shadow caster pass helpers
pass@pass@Example: // Shadow caster pass helpers
helpers@helpers@Example: // Shadow caster pass helpers
#ifdef@#ifdef@Example: #ifdef SHADOWS_CUBE
SHADOWS_CUBE@SHADOWS_CUBE@Example: #ifdef SHADOWS_CUBE
V2F_SHADOW_CASTER@V2F_SHADOW_CASTER@Body: #define V2F_SHADOW_CASTER float4 pos : SV_POSITION; float3 vec : TEXCOORD0
TRANSFER_SHADOW_CASTER(o)@TRANSFER_SHADOW_CASTER(o)@Body: #define TRANSFER_SHADOW_CASTER(o) o.vec = mul( _Object2World, v.vertex ).xyz - _LightPositionRange.xyz; o.pos = mul(UNITY_MATRIX_MVP, v.vertex);
SHADOW_CASTER_FRAGMENT(i)@SHADOW_CASTER_FRAGMENT(i)@Body: #define SHADOW_CASTER_FRAGMENT(i) return EncodeFloatRGBA( min(length(i.vec) * _LightPositionRange.w, 0.999) );
#else@#else@Body: #else
float4@float4@Example: float4 hpos : TEXCOORD0
hpos@hpos@Example: float4 hpos : TEXCOORD0
TEXCOORD0@TEXCOORD0@Example: float4 hpos : TEXCOORD0
unity_LightShadowBias@unity_LightShadowBias@Example: o.pos.z += unity_LightShadowBias.x;
lerp@lerp@Example: o.pos.z = lerp(o.pos.z, clamped, unity_LightShadowBias.y);
clamped@clamped@Example: o.pos.z = lerp(o.pos.z, clamped, unity_LightShadowBias.y);
unity_LightShadowBias@unity_LightShadowBias@Example: o.pos.z = lerp(o.pos.z, clamped, unity_LightShadowBias.y);
hpos@hpos@Example: o.hpos = o.pos;
#else@#else@Body: #else
unity_LightShadowBias@unity_LightShadowBias@Example: o.pos.z += unity_LightShadowBias.x;
lerp@lerp@Example: o.pos.z = lerp(o.pos.z, clamped, unity_LightShadowBias.y);
clamped@clamped@Example: o.pos.z = lerp(o.pos.z, clamped, unity_LightShadowBias.y);
unity_LightShadowBias@unity_LightShadowBias@Example: o.pos.z = lerp(o.pos.z, clamped, unity_LightShadowBias.y);
#endif@#endif@Body: #endif
SHADOW_CASTER_FRAGMENT(i)@SHADOW_CASTER_FRAGMENT(i)@Body: #define SHADOW_CASTER_FRAGMENT(i) UNITY_OUTPUT_DEPTH(i.hpos.zw);
#endif@#endif@Body: #endif
Shadow@Shadow@Example: // Shadow collector pass helpers
collector@collector@Example: // Shadow collector pass helpers
pass@pass@Example: // Shadow collector pass helpers
helpers@helpers@Example: // Shadow collector pass helpers
#ifdef@#ifdef@Example: #ifdef SHADOW_COLLECTOR_PASS
SHADOW_COLLECTOR_PASS@SHADOW_COLLECTOR_PASS@Example: #ifdef SHADOW_COLLECTOR_PASS
defined@defined@Example: #if !defined(SHADOWMAPSAMPLER_DEFINED)
SHADOWMAPSAMPLER_DEFINED@SHADOWMAPSAMPLER_DEFINED@Example: #if !defined(SHADOWMAPSAMPLER_DEFINED)
UNITY_DECLARE_SHADOWMAP@UNITY_DECLARE_SHADOWMAP@Example: UNITY_DECLARE_SHADOWMAP(_ShadowMapTexture);
_ShadowMapTexture@_ShadowMapTexture@Example: UNITY_DECLARE_SHADOWMAP(_ShadowMapTexture);
#endif@#endif@Body: #endif
V2F_SHADOW_COLLECTOR@V2F_SHADOW_COLLECTOR@Body: #define V2F_SHADOW_COLLECTOR float4 pos : SV_POSITION; float3 _ShadowCoord0 : TEXCOORD0; float3 _ShadowCoord1 : TEXCOORD1; float3 _ShadowCoord2 : TEXCOORD2; float3 _ShadowCoord3 : TEXCOORD3; float4 _WorldPosViewZ : TEXCOORD4
TRANSFER_SHADOW_COLLECTOR(o)@TRANSFER_SHADOW_COLLECTOR(o)@Body: #define TRANSFER_SHADOW_COLLECTOR(o)	\
UNITY_MATRIX_MVP@UNITY_MATRIX_MVP@Example: o.pos = mul(UNITY_MATRIX_MVP, v.vertex);
vertex@vertex@Example: o.pos = mul(UNITY_MATRIX_MVP, v.vertex);
defined@defined@Example: #if defined (SHADOWS_NATIVE)
SHADOWS_NATIVE@SHADOWS_NATIVE@Example: #if defined (SHADOWS_NATIVE)
SAMPLE_SHADOW_COLLECTOR_SHADOW(coord)@SAMPLE_SHADOW_COLLECTOR_SHADOW(coord)@Body: #define SAMPLE_SHADOW_COLLECTOR_SHADOW(coord) \
half@half@Example: half shadow = UNITY_SAMPLE_SHADOW(_ShadowMapTexture,coord);
shadow@shadow@Example: half shadow = UNITY_SAMPLE_SHADOW(_ShadowMapTexture,coord);
UNITY_SAMPLE_SHADOW@UNITY_SAMPLE_SHADOW@Example: half shadow = UNITY_SAMPLE_SHADOW(_ShadowMapTexture,coord);
_ShadowMapTexture@_ShadowMapTexture@Example: half shadow = UNITY_SAMPLE_SHADOW(_ShadowMapTexture,coord);
coord@coord@Example: half shadow = UNITY_SAMPLE_SHADOW(_ShadowMapTexture,coord);
#else@#else@Body: #else
#endif@#endif@Body: #endif
COMPUTE_SHADOW_COLLECTOR_SHADOW(i,@COMPUTE_SHADOW_COLLECTOR_SHADOW(i,@Body: #define COMPUTE_SHADOW_COLLECTOR_SHADOW(i, weights, shadowFade) \
float4@float4@Example: float4 coord = float4(i._ShadowCoord0 * weights[0] + i._ShadowCoord1 * weights[1] + i._ShadowCoord2 * weights[2] + i._ShadowCoord3 * weights[3], 1);
coord@coord@Example: float4 coord = float4(i._ShadowCoord0 * weights[0] + i._ShadowCoord1 * weights[1] + i._ShadowCoord2 * weights[2] + i._ShadowCoord3 * weights[3], 1);
float4@float4@Example: float4 coord = float4(i._ShadowCoord0 * weights[0] + i._ShadowCoord1 * weights[1] + i._ShadowCoord2 * weights[2] + i._ShadowCoord3 * weights[3], 1);
_ShadowCoord0@_ShadowCoord0@Example: float4 coord = float4(i._ShadowCoord0 * weights[0] + i._ShadowCoord1 * weights[1] + i._ShadowCoord2 * weights[2] + i._ShadowCoord3 * weights[3], 1);
weights[0]@weights[0]@Example: float4 coord = float4(i._ShadowCoord0 * weights[0] + i._ShadowCoord1 * weights[1] + i._ShadowCoord2 * weights[2] + i._ShadowCoord3 * weights[3], 1);
_ShadowCoord1@_ShadowCoord1@Example: float4 coord = float4(i._ShadowCoord0 * weights[0] + i._ShadowCoord1 * weights[1] + i._ShadowCoord2 * weights[2] + i._ShadowCoord3 * weights[3], 1);
weights[1]@weights[1]@Example: float4 coord = float4(i._ShadowCoord0 * weights[0] + i._ShadowCoord1 * weights[1] + i._ShadowCoord2 * weights[2] + i._ShadowCoord3 * weights[3], 1);
_ShadowCoord2@_ShadowCoord2@Example: float4 coord = float4(i._ShadowCoord0 * weights[0] + i._ShadowCoord1 * weights[1] + i._ShadowCoord2 * weights[2] + i._ShadowCoord3 * weights[3], 1);
weights[2]@weights[2]@Example: float4 coord = float4(i._ShadowCoord0 * weights[0] + i._ShadowCoord1 * weights[1] + i._ShadowCoord2 * weights[2] + i._ShadowCoord3 * weights[3], 1);
_ShadowCoord3@_ShadowCoord3@Example: float4 coord = float4(i._ShadowCoord0 * weights[0] + i._ShadowCoord1 * weights[1] + i._ShadowCoord2 * weights[2] + i._ShadowCoord3 * weights[3], 1);
weights[3]@weights[3]@Example: float4 coord = float4(i._ShadowCoord0 * weights[0] + i._ShadowCoord1 * weights[1] + i._ShadowCoord2 * weights[2] + i._ShadowCoord3 * weights[3], 1);
defined@defined@Example: #if defined (SHADOWS_SPLIT_SPHERES)
SHADOWS_SPLIT_SPHERES@SHADOWS_SPLIT_SPHERES@Example: #if defined (SHADOWS_SPLIT_SPHERES)
SHADOW_COLLECTOR_FRAGMENT(i)@SHADOW_COLLECTOR_FRAGMENT(i)@Body: #define SHADOW_COLLECTOR_FRAGMENT(i) \
float3@float3@Example: float3 fromCenter0 = i._WorldPosViewZ.xyz - unity_ShadowSplitSpheres[0].xyz;
fromCenter0@fromCenter0@Example: float3 fromCenter0 = i._WorldPosViewZ.xyz - unity_ShadowSplitSpheres[0].xyz;
_WorldPosViewZ@_WorldPosViewZ@Example: float3 fromCenter0 = i._WorldPosViewZ.xyz - unity_ShadowSplitSpheres[0].xyz;
unity_ShadowSplitSpheres[0]@unity_ShadowSplitSpheres[0]@Example: float3 fromCenter0 = i._WorldPosViewZ.xyz - unity_ShadowSplitSpheres[0].xyz;
